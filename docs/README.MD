현재의 코드, OrderServiceImpl은 인터페이스 DiscountPolicy와 구현체인 FixDiscountPolicy 모두 의존하고 있다.
OCP,DOI를 잘 지키려면 구현체에 의존해서는 안된다.
따라서 인터페이스에만 의존하는 것이 바람직하다.
그럼 구현체는 어떻게 하냐? 구현체가 없는데 프로그램이 어떻게 돌아가나?
누군가 외부에서 구현체를 설정해줘야한다. 의존성 주입

마치 남배우가 직접 여자주인공을 정하는거와 같다.
책임이 너무 많아진다.
"관심사를 분리하자"
별도의 "공연 기획자"가 나올 시점이다.

---

AppConfig의 등장

구현 객체를 생성하고 연결하는 책임을 갖는 별도의 클래스

객체들이 자기할일만 할 수 있게 도와준다

사용 영역과 구성 영역으로 분리

사용 영역은 바꾸지 않고 구성 영역만 바꿔서 요구사항에 대응할 수 있다


IoC(Inversion of Control)
프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는것 -> ioc
예를 들어 이 프로그램에서는 AppConfig가 프로그램의 흐름을 주도한다.
MemberServiceImpl같은 경우 자기가 어떤 구현체를 쓰게 될지 모르고 그냥 묵묵히 자기 일을 할 뿐이다.
객체가 스스로 프로그램의 제어 흐름을 조종하는 것이 아닌, 외부에서 관리 하는것이 제어의 역전이다

정적 의존관계 -> 소스코드를 보고 알 수 있는 의존 관계 (인텔리제이 -> 폴더 우클릭 -> diagrams -> show dependency)
동적 객체 인스턴스 의존관계 -> 실행 시점에 결정되는 의존 관계 (입력에 따른 정액 할인, 비율 할인.. )
의존성 주입 == 의존관계 주입

IOC컨테이너 , DI컨테이너
AppConfig처럼 객체를 생성하고 관리하면서 의존관계를 연결해주는걸 IOC컨테이너, DI컨테이너라 한다.
IOC 컨테이너 = DI 컨테이너 = 어셈블러 = 오브젝트 팩토리

ApplicationContext => 스프링 컨테이너
기존에는 AppConfig를 사용해서 DI를 했지만, 스프링 컨테이너를 사용한다
@Bean이라고 적힌 메서드들을 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록한다. 등록된 객체를 스프링 빈이라고 한다
스프링 컨테이너의 장점은?
